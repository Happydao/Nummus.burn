<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BURN Dashboard — Live</title>
  <meta name="description" content="Live burn dashboard on Solana: totals, USD value, supply, last update, burn address and recent burn transactions." />
  <link rel="preload" as="image" href="bg-desktop.png">
  <link rel="preload" as="image" href="bg-thumb.webp">
  <style>
    :root{
      --glass-bg: rgba(0,0,0,0.38);
      --glass-border: rgba(255,255,255,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;
      --accent2: #ff5fd2;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0b12; color: var(--text); overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config ----
    const BG_SRC      = 'bg-desktop.png';       // main background con titolo integrato
    const THUMB_SRC   = 'bg-thumb.webp';        // small preview (optional)

    const BURN_JSON   = 'data/burn.json';
    const PRICE_JSON  = 'data/price.json';
    const FIT_MODE    = 'cover'; // sempre cover

    const DRAW_UI_ONLY_WHEN_READY = true;
    const USE_THUMB_PLACEHOLDER   = false;

    // ===== Layout (tutto spinto in alto) =====
    // Contenitore unico (cards + mini info + tabella) vicino alla parte alta dell'immagine
    let CONTAINER_TOP_Y_PCT = 0.30; // default 38% dall'alto — spinto in alto rispetto a prima
    let BOTTOM_PRICE_Y      = 0.94;

    // Per assetto rapido da URL: ?tableY=36 (percentuale) & focusY=0.30
    let BG_FOCUS_X = 0.5, BG_FOCUS_Y = 0.30; // mostra più "cielo"/titolo

    // ===== Links =====
    const GITHUB_REPO_URL    = 'https://github.com/Happydao/Bumper.burn';
    const BURN_ADDRESS       = '5G62fW1BuK6k9B6sGwvTBtoKRPseshj9SSYPzudSPUYE';
    const BURN_SOLSCAN_URL   = 'https://solscan.io/account/' + BURN_ADDRESS;

    // Colors
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.38)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: '#9ee8ff'
    };

    // Canvas
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function resizeCanvasToDisplaySize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }

    function scaleUnit() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const s = Math.min(w / 1440, h / 900);
      return Math.max(0.65, Math.min(1.15, s));
    }
    const px = (n)=> Math.round(n * scaleUnit());

    // URL tweaks
    (function tweaks(){
      try{
        const qs = new URLSearchParams(location.search);
        const ty = Number(qs.get('tableY')); if (!Number.isNaN(ty)) CONTAINER_TOP_Y_PCT = Math.min(0.70, Math.max(0.26, ty/100));
        const fy = Number(qs.get('focusY')); if (!Number.isNaN(fy)) BG_FOCUS_Y = Math.min(1, Math.max(0, fy));
      }catch{}
    })();

    // -------- Progressive background loading --------
    let thumbBitmap = null;
    let mainBitmap  = null;
    let bgReady = false;
    let fadeAlpha = 0; // 0..1

    async function loadBitmap(src){
      try {
        const res = await fetch(src, { cache: 'force-cache' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        return await createImageBitmap(blob);
      } catch (e) {
        console.warn('Image load failed:', src, e.message);
        return null;
      }
    }

    (async function initBackground(){
      thumbBitmap = await loadBitmap(THUMB_SRC); draw();
      mainBitmap  = await loadBitmap(BG_SRC);
      if (mainBitmap) { bgReady = true; const start = performance.now();
        function step(t){ const k = Math.min(1, (t-start)/450); fadeAlpha = k; draw(); if (k<1) requestAnimationFrame(step); }
        requestAnimationFrame(step);
      } else draw();
    })();

    // Data
    let burn = null;  // { totalUi, burns, count, updatedAt? }
    let price = null; // { priceUsd, burnTotalUsd, totalSupplyTokensNum, updatedAt? }

    let linkHitboxes = [];

    function cacheBust(url){ return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); }
    async function loadJson(url){ const res = await fetch(cacheBust(url), { cache: 'no-store' }); if (!res.ok) throw new Error('HTTP '+res.status+' for '+url); return res.json(); }
    async function refreshData(){
      try { const [b, p] = await Promise.all([ loadJson(BURN_JSON).catch(()=>null), loadJson(PRICE_JSON).catch(()=>null) ]); burn = b; price = p; }
      catch(e){ console.error(e); }
      finally { draw(); }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){ const rr = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
    function drawGlass(x, y, w, h){
      // base glass
      roundRectPath(x, y, w, h, px(14));
      ctx.fillStyle = 'rgba(0,0,0,0.46)'; // più scuro per contrasto
      ctx.fill();
      // bordo doppio: chiaro + glow
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.stroke();
      // inner stroke colorato leggero
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(120,255,178,0.25)';
      ctx.stroke();
      // shadow soft
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.45)';
      ctx.shadowBlur = px(14);
      ctx.shadowOffsetY = px(2);
      roundRectPath(x, y, w, h, px(14));
      ctx.strokeStyle = 'rgba(0,0,0,0)';
      ctx.stroke();
      ctx.restore();
    }
    function text(opts){ const { str,x,y,size=20,weight=400,color=COLOR.text,align='left',baseline='alphabetic'}=opts; ctx.fillStyle=color; ctx.font = `${weight} ${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`; ctx.textAlign=align; ctx.textBaseline=baseline; ctx.fillText(str,x,y); }
    function fitNumber(n, maxDp){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6); return n.toLocaleString(undefined, { maximumFractionDigits: dp }); }
    function money(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }); }
    function formatSupplyCompact(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); if (abs >= 1e9) return (n/1e9).toLocaleString(undefined,{ maximumFractionDigits: 3 })+' B'; if (abs >= 1e6) return (n/1e6).toLocaleString(undefined,{ maximumFractionDigits: 3 })+' M'; if (abs >= 1e3) return (n/1e3).toLocaleString(undefined,{ maximumFractionDigits: 3 }); return n.toLocaleString(undefined,{ maximumFractionDigits: 3 }); }
    function shorten(addr){ return (addr && addr.length>14) ? addr.slice(0,8)+'…'+addr.slice(-6) : addr; }

    function drawBackground(w, h){
      // darker bottom for readability
      const grad = ctx.createLinearGradient(0,0,0,h);
      grad.addColorStop(0, 'rgba(0,0,0,0.12)');
      grad.addColorStop(1, 'rgba(0,0,0,0.40)');

      const bmp = mainBitmap || thumbBitmap;
      if (bmp){
        const imgW = bmp.width, imgH = bmp.height;
        const scale = (FIT_MODE==='cover') ? Math.max(w/imgW, h/imgH) : Math.min(w/imgW, h/imgH);
        const sw = Math.min(imgW, Math.round(w/scale));
        const sh = Math.min(imgH, Math.round(h/scale));
        const cx = Math.round(BG_FOCUS_X*imgW), cy = Math.round(BG_FOCUS_Y*imgH);
        const sx = Math.max(0, Math.min(imgW - sw, cx - Math.round(sw/2)));
        const sy = Math.max(0, Math.min(imgH - sh, cy - Math.round(sh/2)));
        ctx.drawImage(bmp, sx, sy, sw, sh, 0, 0, w, h);
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
      } else { ctx.fillStyle = '#0b0b12'; ctx.fillRect(0,0,w,h); }
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      drawBackground(w,h);
      linkHitboxes = [];

      // GitHub pill
      (function gh(){ const label='GitHub'; const padX=px(10), padY=px(6); ctx.font=`700 ${px(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; const tw=ctx.measureText(label).width; const bw=Math.ceil(tw+padX*2), bh=Math.ceil(px(28)); const bx=Math.floor(w-bw-px(12)); const by=Math.floor(px(12)); drawGlass(bx,by,bw,bh); text({str:label,x:bx+Math.floor(bw/2),y:by+Math.floor(bh/2)+1,size:px(12),weight:700,color:COLOR.text,align:'center',baseline:'middle'}); linkHitboxes.push({x:bx,y:by,w:bw,h:bh,url:GITHUB_REPO_URL}); })();

      const dataReady = !!(burn && price);
      const uiReady = (!!mainBitmap && dataReady) || (!DRAW_UI_ONLY_WHEN_READY);
      if (!uiReady) return;

      // === Container unico: cards in alto + mini info + tabella sotto ===
      const labelSize = px(12), labelWeight = 700;
      const valueSize = px(22), valueWeight = 800;
      const padX = px(14), padY = px(10), vGap = px(6);

      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const pxUsd = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * pxUsd);

      const rowsAll = (burn?.burns || []);
      const maxRows = w < 520 ? 8 : (w < 900 ? 12 : 20);
      const rows = rowsAll.slice(0, maxRows);

      // dimensioni principali
      const tableW = Math.min(Math.max(px(420), Math.floor(w*0.92)), px(1100));
      const rowH   = px(24), headH = px(32), tPad = px(12);

      // Top row: due card dentro al contenitore
      // calcolo larghezze card (fit-to-text)
      const label1 = 'Total burned';
      const value1 = `${fitNumber(totalTokens, 6)} BUMPER`;
      ctx.font = `${labelWeight} ${labelSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const c1LabelW = ctx.measureText(label1).width;
      ctx.font = `${valueWeight} ${valueSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const c1ValueW = ctx.measureText(value1).width;
      const card1W = Math.ceil(Math.max(c1LabelW, c1ValueW) + padX*2);
      const card1H = Math.ceil(padY*2 + labelSize + vGap + valueSize);

      const label2 = 'Total USD burned';
      const value2 = money(totalUsd);
      ctx.font = `${labelWeight} ${labelSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const c2LabelW = ctx.measureText(label2).width;
      ctx.font = `${valueWeight} ${valueSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const c2ValueW = ctx.measureText(value2).width;
      const card2W = Math.ceil(Math.max(c2LabelW, c2ValueW) + padX*2);
      const card2H = Math.ceil(padY*2 + labelSize + vGap + valueSize);

      const cardsH = Math.max(card1H, card2H);
      const cardsGap = Math.min(px(24), Math.floor(tableW*0.06));

      // Seconda riga: mini info (supply, last updated, burn address)
      const miniH = px(40), miniGap = px(10);

      const supplyNum = (price && typeof price.totalSupplyTokensNum === 'number') ? price.totalSupplyTokensNum : (price && price.totalSupplyTokens ? Number(price.totalSupplyTokens) : 0);
      const supplyStr = `Total supply: ${formatSupplyCompact(supplyNum)}`;
      ctx.font = `700 ${px(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      let meas = ctx.measureText(supplyStr);
      const supplyW = Math.min(Math.max(meas.width + px(24), px(220)), px(360));

      const updated = price?.updatedAt || burn?.updatedAt || null;
      const updatedStr = updated ? `Last updated: ${new Date(updated).toLocaleString()}` : 'Last updated: —';
      meas = ctx.measureText(updatedStr);
      const updW = Math.min(Math.max(meas.width + px(24), px(220)), px(420));

      const midFreeW = Math.max(0, tableW - (supplyW + updW + px(24))); // spazio centrale per burn address

      // Altezza contenitore totale
      const tableRowsH = headH + Math.max(1, rows.length) * rowH + tPad*2;
      const containerH = tPad + cardsH + tPad + miniH + tPad + tableRowsH + tPad;

      // Posizionamento contenitore
      const containerX = Math.floor((w - tableW)/2);
      let   containerY = Math.floor(h * CONTAINER_TOP_Y_PCT);
      if (containerY < px(80)) containerY = px(80); // non andare troppo su
      if (containerY + containerH > h - px(12)) containerY = Math.max(px(12), h - px(12) - containerH);

      // Disegno contenitore
      drawGlass(containerX, containerY, tableW, containerH);

      // --- RIGA 1: tre elementi: (sx) Burn address card, (centro) due card Total ---
      const cardsY = containerY + tPad;

      // Burn address card (sinistra)
      const burnLbl = `Burn address`;
      const burnVal = shorten(BURN_ADDRESS);
      ctx.font = `${labelWeight} ${labelSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const baLblW = ctx.measureText(burnLbl).width;
      ctx.font = `${valueWeight} ${valueSize - px(6)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const baValW = ctx.measureText(burnVal).width;
      const burnW = Math.ceil(Math.max(baLblW, baValW) + padX*2);
      const burnH = Math.ceil(padY*2 + labelSize + vGap + (valueSize - px(6)));
      const burnX = containerX + tPad;

      drawGlass(burnX, cardsY, burnW, burnH);
      text({ str: burnLbl, x: burnX + padX, y: cardsY + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, baseline: 'top' });
      text({ str: burnVal, x: burnX + padX, y: cardsY + padY + labelSize + vGap, size: valueSize - px(6), weight: valueWeight, color: COLOR.link, baseline: 'top' });
      // hitbox burn
      linkHitboxes.push({ x: burnX, y: cardsY, w: burnW, h: burnH, url: BURN_SOLSCAN_URL });

      // due card centrali (Total burned + Total USD burned)
      const gapMid = Math.min(px(18), Math.floor(tableW*0.04));
      const centerBlockW = card1W + gapMid + card2W;
      const cCenterX = containerX + Math.floor(tableW/2);
      const cBlockX = cCenterX - Math.floor(centerBlockW/2);
      const c1x = cBlockX;
      const c2x = cBlockX + card1W + gapMid;

      // card 1
      drawGlass(c1x, cardsY, card1W, card1H);
      text({ str: label1, x: c1x + padX, y: cardsY + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, baseline: 'top' });
      text({ str: value1, x: c1x + padX, y: cardsY + padY + labelSize + vGap, size: valueSize, weight: valueWeight, color: COLOR.accent, baseline: 'top' });

      // card 2
      drawGlass(c2x, cardsY, card2W, card2H);
      text({ str: label2, x: c2x + card2W - padX, y: cardsY + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, align: 'right', baseline: 'top' });
      text({ str: value2, x: c2x + padX, y: cardsY + padY + labelSize + vGap, size: valueSize, weight: valueWeight, color: COLOR.accent2, baseline: 'top' });

      // --- RIGA 2: mini info (sx supply, centro VUOTO, dx updated) ---
      const miniY = cardsY + cardsH + tPad;

      // supply sx
      const supplyX = containerX + tPad;
      drawGlass(supplyX, miniY, supplyW, miniH);
      text({ str: supplyStr, x: supplyX + px(12), y: miniY + Math.floor(miniH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.text });

      // updated dx
      const updX = containerX + tableW - tPad - updW;
      drawGlass(updX, miniY, updW, miniH);
      text({ str: updatedStr, x: updX + px(12), y: miniY + Math.floor(miniH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.muted });

      // (centro lasciato libero per respiro visivo)

      // --- RIGA 3: tabella burns ---
      const tableX = containerX + tPad;
      const tableY = miniY + miniH + tPad;
      const tableInnerW = tableW - tPad*2;

      // titolo sezione
      text({ str: 'Recent burns', x: tableX + px(10), y: tableY + px(6), size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      // intestazioni
      const headersY = tableY + px(28);
      text({ str: '#',                   x: tableX+px(10),                         y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Amount (token)',      x: tableX+px(10)+px(32)+8,                y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Transaction',         x: tableX+px(10)+px(32)+Math.max(px(150), Math.floor(tableInnerW*0.28))+8, y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      const colIndexW = px(32);
      const colQtyW   = Math.max(px(150), Math.floor(tableInnerW*0.28));
      const rowStartY = headersY + px(22);

      if (rows.length === 0){
        text({ str: 'No burns found.', x: tableX+px(10), y: rowStartY+px(6), size: px(14), color: COLOR.muted, weight: 700, baseline: 'top' });
      } else {
        for (let i=0; i<rows.length; i++){
          const ry = rowStartY + i*rowH;
          const row = rows[i]; const qty = Number(row.amountUi || 0); const url = row.url || '#';
          text({ str: String(i+1), x: tableX+px(10), y: ry+Math.floor(rowH*0.68), size: px(12), color: COLOR.text, weight: 700 });
          text({ str: fitNumber(qty, 6), x: tableX+px(10)+colIndexW+8, y: ry+Math.floor(rowH*0.68), size: px(14), color: COLOR.text, weight: 800 });
          const linkStr = 'Open on Solscan';
          ctx.font = `700 ${px(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
          ctx.fillStyle = COLOR.link; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
          ctx.fillText(linkStr, tableX+px(10)+colIndexW+colQtyW+8, ry+Math.floor(rowH*0.68));
          const m2 = ctx.measureText(linkStr);
          linkHitboxes.push({ x: tableX+px(10)+colIndexW+colQtyW+8, y: ry - Math.floor(rowH*0.2), w: m2.width, h: Math.floor(rowH*0.9), url });
        }
      }

      // --- Badge prezzo in basso ---
      const priceStr = (pxUsd ? pxUsd.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const priceLabel = `Token price: ${priceStr} USD`;
      ctx.font = `700 ${px(16)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const m = ctx.measureText(priceLabel);
      const bottomY = Math.floor(h * BOTTOM_PRICE_Y);
      const pad2 = px(10), bh = px(34), bw = m.width + pad2*2;
      const bx = Math.floor((w - bw)/2), by = Math.floor(bottomY - bh/2);
      drawGlass(bx, by, bw, bh);
      text({ str: priceLabel, x: Math.floor(w/2), y: bottomY+1, size: px(16), weight: 700, align: 'center', baseline: 'middle' });
    }

    // Interactivity
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) window.open(hit.url, '_blank', 'noopener');
    });

    window.addEventListener('resize', draw);
    refreshData();
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>

