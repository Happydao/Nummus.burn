<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NUMMUS BURN — Live Dashboard</title>
  <meta name="description" content="Live burn dashboard on Solana: totals, USD value, supply, last update and recent burn transactions for NUMMUS." />
  <link rel="preload" as="image" href="bg-desktop.png">
  <link rel="preload" as="image" href="bg-thumb.webp">
  <link rel="preload" as="image" href="nummus.burn.png">
  <style>
    :root{
      --glass-bg: rgba(0,0,0,0.46);
      --glass-border: rgba(255,255,255,0.35);
      --glass-accent: rgba(120,255,178,0.25);
      --text: #f3f3f3;
      --muted: #c8c8c8;
      --accent: #78ffb2;
      --accent2: #ff5fd2;
      --link: #9ee8ff;
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0b12; color: var(--text); overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="stage" width="1920" height="1080"></canvas>

  <script>
    // ---- Config ----
    const BG_SRC      = 'bg-desktop.png';
    const THUMB_SRC   = 'bg-thumb.webp';

    const BURN_JSON   = 'data/burn.json';
    const PRICE_JSON  = 'data/price.json';
    const FIT_MODE    = 'cover';

    const DRAW_UI_ONLY_WHEN_READY = true;
    const USE_THUMB_PLACEHOLDER   = false;

    // ===== Layout =====
    let CONTAINER_TOP_Y_PCT = 0.20; // posizione del pannello (puoi regolare con ?tableY=xx)
    let BOTTOM_INFO_Y       = 0.94; // baseline per badge in basso (last updated / price)

    // Background focus (0=alto, 1=basso)
    let BG_FOCUS_X = 0.5, BG_FOCUS_Y = 0.30;

    // Links (se ti serve esporli)
    const GITHUB_REPO_URL = 'https://github.com/Happydao/Nummus.burn';

    // Colors
    const COLOR = {
      text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#f3f3f3',
      muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#c8c8c8',
      glass: getComputedStyle(document.documentElement).getPropertyValue('--glass-bg').trim() || 'rgba(0,0,0,0.46)',
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--glass-border').trim() || 'rgba(255,255,255,0.35)',
      stroke2: getComputedStyle(document.documentElement).getPropertyValue('--glass-accent').trim() || 'rgba(120,255,178,0.25)',
      accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#78ffb2',
      accent2: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ff5fd2',
      link: getComputedStyle(document.documentElement).getPropertyValue('--link').trim() || '#9ee8ff'
    };

    // Canvas
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function resizeCanvasToDisplaySize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }

    function scaleUnit() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const s = Math.min(w / 1440, h / 900);
      return Math.max(0.65, Math.min(1.15, s));
    }
    const px = (n)=> Math.round(n * scaleUnit());

    // URL tweaks
    (function tweaks(){
      try{
        const qs = new URLSearchParams(location.search);
        const ty = Number(qs.get('tableY')); if (!Number.isNaN(ty)) CONTAINER_TOP_Y_PCT = ty/100;
        const fy = Number(qs.get('focusY')); if (!Number.isNaN(fy)) BG_FOCUS_Y = Math.min(1, Math.max(0, fy));
      }catch{}
    })();

    // -------- Assets --------
    let thumbBitmap = null, mainBitmap  = null, bgReady = false, fadeAlpha = 0;

    async function loadBitmap(src){
      try { const res = await fetch(src, { cache: 'force-cache' }); if (!res.ok) throw new Error('HTTP '+res.status); const blob = await res.blob(); return await createImageBitmap(blob); }
      catch (e) { console.warn('Image load failed:', src, e.message); return null; }
    }

    // Title image
    const titleImg = new Image();
    let titleReady = false;
    titleImg.onload = ()=>{ titleReady = true; draw(); };
    titleImg.onerror = ()=>{ console.warn('Failed to load title image: nummus.burn.png'); };
    titleImg.src = 'nummus.burn.png';

    (async function initBackground(){
      thumbBitmap = await loadBitmap(THUMB_SRC); draw();
      mainBitmap  = await loadBitmap(BG_SRC);
      if (mainBitmap) { bgReady = true; const start = performance.now();
        function step(t){ const k = Math.min(1, (t-start)/450); fadeAlpha = k; draw(); if (k<1) requestAnimationFrame(step); }
        requestAnimationFrame(step);
      } else draw();
    })();

    // Data
    let burn = null;  // { totalUi, burns, count, updatedAt? }
    let price = null; // { priceUsd, burnTotalUsd, totalSupplyTokensNum, updatedAt? }

    let linkHitboxes = [];

    function cacheBust(url){ return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); }
    async function loadJson(url){ const res = await fetch(cacheBust(url), { cache: 'no-store' }); if (!res.ok) throw new Error('HTTP '+res.status+' for '+url); return res.json(); }
    async function refreshData(){
      try { const [b, p] = await Promise.all([ loadJson(BURN_JSON).catch(()=>null), loadJson(PRICE_JSON).catch(()=>null) ]); burn = b; price = p; }
      catch(e){ console.error(e); }
      finally { draw(); }
    }

    // Helpers
    function roundRectPath(x, y, w, h, r){ const rr = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
    function drawGlass(x, y, w, h){
      roundRectPath(x, y, w, h, px(14));
      ctx.fillStyle = COLOR.glass; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = COLOR.stroke; ctx.stroke();
      ctx.lineWidth = 1; ctx.strokeStyle = COLOR.stroke2; ctx.stroke();
      ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.45)'; ctx.shadowBlur = px(14); ctx.shadowOffsetY = px(2);
      roundRectPath(x, y, w, h, px(14)); ctx.strokeStyle = 'rgba(0,0,0,0)'; ctx.stroke(); ctx.restore();
    }
    function drawPanel(x, y, w, h){
      roundRectPath(x, y, w, h, px(16));
      ctx.fillStyle = 'rgba(0,0,0,0.52)'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.45)'; ctx.stroke();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(120,255,178,0.35)'; ctx.stroke();
      ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,95,210,0.30)'; ctx.stroke();
      const g = ctx.createLinearGradient(x, y, x, y+px(54));
      g.addColorStop(0, 'rgba(255,255,255,0.12)'); g.addColorStop(1, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = g; ctx.fillRect(x+px(2), y+px(2), w-px(4), px(54));
    }
    function text(opts){ const { str,x,y,size=20,weight=400,color=COLOR.text,align='left',baseline='alphabetic'}=opts; ctx.fillStyle=color; ctx.font = `${weight} ${size}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; ctx.textAlign=align; ctx.textBaseline=baseline; ctx.fillText(str,x,y); }
    function fitNumber(n, maxDp){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); const dp = abs >= 1 ? Math.min(maxDp, 2) : Math.min(maxDp, 6); return n.toLocaleString(undefined, { maximumFractionDigits: dp }); }
    function money(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; return n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }); }
    function formatSupplyCompact(n){ if (typeof n !== 'number' || !isFinite(n)) return '—'; const abs = Math.abs(n); if (abs >= 1e9) return (n/1e9).toLocaleString(undefined,{ maximumFractionDigits: 3 })+' B'; if (abs >= 1e6) return (n/1e6).toLocaleString(undefined,{ maximumFractionDigits: 3 })+' M'; if (abs >= 1e3) return (n/1e3).toLocaleString(undefined,{ maximumFractionDigits: 3 }); return n.toLocaleString(undefined,{ maximumFractionDigits: 3 }); }

    function drawBackground(w, h){
      const bmp = mainBitmap || thumbBitmap;
      const baseGrad = ctx.createLinearGradient(0,0,0,h);
      baseGrad.addColorStop(0, 'rgba(0,0,0,0.12)'); baseGrad.addColorStop(1, 'rgba(0,0,0,0.40)');
      if (bmp){
        const imgW = bmp.width, imgH = bmp.height;
        const scale = (FIT_MODE==='cover') ? Math.max(w/imgW, h/imgH) : Math.min(w/imgW, h/imgH);
        const sw = Math.min(imgW, Math.round(w/scale));
        const sh = Math.min(imgH, Math.round(h/scale));
        const cx = Math.round(BG_FOCUS_X*imgW), cy = Math.round(BG_FOCUS_Y*imgH);
        const sx = Math.max(0, Math.min(imgW - sw, cx - Math.round(sw/2)));
        const sy = Math.max(0, Math.min(imgH - sh, cy - Math.round(sh/2)));
        ctx.drawImage(bmp, sx, sy, sw, sh, 0, 0, w, h);
        ctx.fillStyle = baseGrad; ctx.fillRect(0,0,w,h);
      } else { ctx.fillStyle = '#0b0b12'; ctx.fillRect(0,0,w,h); }
    }

    function draw(){
      resizeCanvasToDisplaySize();
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      drawBackground(w,h);
      linkHitboxes = [];

      // GitHub pill (alto dx)
      (function gh(){ const label='GitHub'; const padX=px(10), padY=px(6); ctx.font=`700 ${px(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; const tw=ctx.measureText(label).width; const bw=Math.ceil(tw+padX*2), bh=Math.ceil(px(28)); const bx=Math.floor(w-bw-px(12)); const by=Math.floor(px(12)); drawGlass(bx,by,bw,bh); text({str:label,x:bx+Math.floor(bw/2),y:by+Math.floor(bh/2)+1,size:px(12),weight:700,color:COLOR.text,align:'center',baseline:'middle'}); linkHitboxes.push({x:bx,y:by,w:bw,h:bh,url:GITHUB_REPO_URL}); })();

      const dataReady = !!(burn && price);
      const uiReady = (!!mainBitmap && dataReady) || (!DRAW_UI_ONLY_WHEN_READY);
      if (!uiReady) return;

      // === Dati ===
      const labelSize = px(12), labelWeight = 700;
      const valueSize = px(22), valueWeight = 800;
      const padX = px(14), padY = px(10), vGap = px(6);

      const totalTokens = burn?.totalUi ? Number(burn.totalUi) : 0;
      const pxUsd = price?.priceUsd ? Number(price.priceUsd) : 0;
      const totalUsd = (price?.burnTotalUsd != null) ? Number(price.burnTotalUsd) : (totalTokens * pxUsd);
      const supplyNum = (price && typeof price.totalSupplyTokensNum === 'number') ? price.totalSupplyTokensNum : (price && price.totalSupplyTokens ? Number(price.totalSupplyTokens) : 0);

      const rowsAll = (burn?.burns || []);
      const maxRows = w < 520 ? 8 : (w < 900 ? 12 : 20);
      const rows = rowsAll.slice(0, maxRows);

      // === Misure pannello ===
      const tableW = Math.min(Math.max(px(520), Math.floor(w*0.92)), px(1200));
      const rowH   = px(24), headH = px(32), tPad = px(12);

      // Card: Total burned (NUMMUS)
      const label1 = 'Total burned'; const value1 = `${fitNumber(totalTokens, 6)} NUMMUS`;
      ctx.font = `${labelWeight} ${labelSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; const c1LabelW = ctx.measureText(label1).width;
      ctx.font = `${valueWeight} ${valueSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; const c1ValueW = ctx.measureText(value1).width;
      const card1W = Math.ceil(Math.max(c1LabelW, c1ValueW) + padX*2); const card1H = Math.ceil(padY*2 + labelSize + vGap + valueSize);

      // Card: Total USD burned
      const label2 = 'Total USD burned'; const value2 = money(totalUsd);
      ctx.font = `${labelWeight} ${labelSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; const c2LabelW = ctx.measureText(label2).width;
      ctx.font = `${valueWeight} ${valueSize}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`; const c2ValueW = ctx.measureText(value2).width;
      const card2W = Math.ceil(Math.max(c2LabelW, c2ValueW) + padX*2); const card2H = Math.ceil(padY*2 + labelSize + vGap + valueSize);

      const cardsH = Math.max(card1H, card2H);

      // Card: Total supply (a sinistra)
      const supplyStr = `Total supply: ${formatSupplyCompact(supplyNum)}`;
      ctx.font = `700 ${px(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      let meas = ctx.measureText(supplyStr);
      const supplyW = Math.min(Math.max(meas.width + px(24), px(220)), px(420));
      const supplyH = px(40);

      // Titolo immagine centrale
      const titleMaxW = Math.min(Math.floor(tableW * 0.44), px(620));
      let titleW = 0, titleH = 0;
      if (titleReady) {
        const ratio = titleImg.naturalWidth / titleImg.naturalHeight;
        titleW = titleMaxW;
        titleH = Math.round(titleW / ratio);
      } else {
        titleW = px(360); titleH = px(64); // fallback spazio
      }

      // Header block height
      const headerBlockH = Math.max(titleH, cardsH, supplyH);

      // Altezza tabella
      const tableRowsH = headH + Math.max(1, rows.length) * rowH + tPad*2 + px(6);
      const panelH = tPad + headerBlockH + tPad + tableRowsH + tPad;

      const panelX = Math.floor((w - tableW)/2);
      let panelY = Math.floor(h * CONTAINER_TOP_Y_PCT);
      if (panelY < px(16)) panelY = px(16);
      if (panelY + panelH > h - px(12)) panelY = Math.max(px(12), h - px(12) - panelH);

      // Pannello principale
      drawPanel(panelX, panelY, tableW, panelH);

      // --- HEADER: supply sx, titolo centro, due card dx ---
      const headerY = panelY + tPad;

      // supply (sx)
      const supplyX = panelX + tPad;
      drawGlass(supplyX, headerY + Math.floor((headerBlockH - supplyH)/2), supplyW, supplyH);
      text({ str: supplyStr, x: supplyX + px(12), y: headerY + Math.floor((headerBlockH - supplyH)/2) + Math.floor(supplyH/2)+1, size: px(12), weight: 700, baseline: 'middle', color: COLOR.text });

      // titolo immagine (centro)
      const titleX = panelX + Math.floor(tableW/2) - Math.floor(titleW/2);
      const titleY = headerY + Math.floor((headerBlockH - titleH)/2);
      if (titleReady) ctx.drawImage(titleImg, titleX, titleY, titleW, titleH);
      else { text({ str: 'NUMMUS BURN', x: titleX + Math.floor(titleW/2), y: titleY + Math.floor(titleH/2), size: px(24), weight: 900, align: 'center', baseline: 'middle' }); }

      // due card a destra
      const gapR = px(18);
      const rightBlockW = card1W + gapR + card2W;
      const rightX = panelX + tableW - tPad - rightBlockW;
      const cardsY = headerY + Math.floor((headerBlockH - cardsH)/2);

      // card 1: Total burned
      drawGlass(rightX, cardsY, card1W, card1H);
      text({ str: label1, x: rightX + padX, y: cardsY + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, baseline: 'top' });
      text({ str: value1, x: rightX + padX, y: cardsY + padY + labelSize + vGap, size: valueSize, weight: valueWeight, color: COLOR.accent, baseline: 'top' });

      // card 2: Total USD burned
      const c2x = rightX + card1W + gapR;
      drawGlass(c2x, cardsY, card2W, card2H);
      text({ str: label2, x: c2x + card2W - padX, y: cardsY + padY + 2, size: labelSize, weight: labelWeight, color: COLOR.muted, align: 'right', baseline: 'top' });
      text({ str: value2, x: c2x + padX, y: cardsY + padY + labelSize + vGap, size: valueSize, weight: valueWeight, color: COLOR.accent2, baseline: 'top' });

      // --- TABELLA ---
      const tableX = panelX + tPad;
      const tableY = headerY + headerBlockH + tPad; // un po' più in basso del bordo alto
      const tableInnerW = tableW - tPad*2;
      const tableH = tableRowsH;

      drawPanel(tableX, tableY, tableInnerW, tableH);

      // Header barra tabella
      const headerBarH = px(36);
      const hbGrad = ctx.createLinearGradient(tableX, tableY, tableX, tableY + headerBarH);
      hbGrad.addColorStop(0, 'rgba(255,255,255,0.10)');
      hbGrad.addColorStop(1, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = hbGrad; ctx.fillRect(tableX+px(2), tableY+px(2), tableInnerW-px(4), headerBarH);

      text({ str: 'Recent burns', x: tableX + px(12), y: tableY + px(10), size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      // intestazioni
      const headersY = tableY + headerBarH + px(4);
      const colIndexW = px(32);
      const colQtyW   = Math.max(px(150), Math.floor(tableInnerW*0.30));
      text({ str: '#',                     x: tableX+px(12),                         y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Amount (NUMMUS)',       x: tableX+px(12)+colIndexW+8,              y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });
      text({ str: 'Transaction',           x: tableX+px(12)+colIndexW+colQtyW+8,      y: headersY, size: px(12), color: COLOR.muted, weight: 800, baseline: 'top' });

      // righe
      const rowStartY = headersY + px(22);
      if (rows.length === 0){
        text({ str: 'No burns found.', x: tableX+px(12), y: rowStartY+px(6), size: px(14), color: COLOR.muted, weight: 700, baseline: 'top' });
      } else {
        for (let i=0; i<rows.length; i++){
          const ry = rowStartY + i*rowH;
          const row = rows[i]; const qty = Number(row.amountUi || 0); const url = row.url || '#';
          // separator line
          ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(tableX+px(10), ry+Math.floor(rowH*0.15)); ctx.lineTo(tableX+tableInnerW-px(10), ry+Math.floor(rowH*0.15)); ctx.stroke();
          text({ str: String(i+1), x: tableX+px(12), y: ry+Math.floor(rowH*0.68), size: px(12), color: COLOR.text, weight: 700 });
          text({ str: fitNumber(qty, 6), x: tableX+px(12)+colIndexW+8, y: ry+Math.floor(rowH*0.68), size: px(14), color: COLOR.text, weight: 800 });
          const linkStr = 'Open on Solscan';
          ctx.font = `700 ${px(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
          ctx.fillStyle = COLOR.link; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
          ctx.fillText(linkStr, tableX+px(12)+colIndexW+colQtyW+8, ry+Math.floor(rowH*0.68));
          const m2 = ctx.measureText(linkStr);
          linkHitboxes.push({ x: tableX+px(12)+colIndexW+colQtyW+8, y: ry - Math.floor(rowH*0.2), w: m2.width, h: Math.floor(rowH*0.9), url });
        }
      }

      // --- Badge in basso: Last updated (sx) e Nummus Price (dx) ---
      const updated = price?.updatedAt || burn?.updatedAt || null;
      const updatedStr = updated ? `Last updated: ${new Date(updated).toLocaleString()}` : 'Last updated: —';
      const priceStr = (pxUsd ? pxUsd.toLocaleString(undefined, { maximumFractionDigits: 6 }) : '—');
      const priceLabel = `Nummus price: ${priceStr} USD`;

      // misura
      ctx.font = `700 ${px(14)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif`;
      const upW = Math.ceil(ctx.measureText(updatedStr).width) + px(24);
      const prW = Math.ceil(ctx.measureText(priceLabel).width) + px(24);
      const badgeH = px(34);
      const bottomY = Math.floor(h * BOTTOM_INFO_Y);

      // sinistra: updated
      const upX = panelX; const upY = bottomY - Math.floor(badgeH/2);
      drawGlass(upX, upY, upW, badgeH);
      text({ str: updatedStr, x: upX + px(12), y: bottomY+1, size: px(14), weight: 700, baseline: 'middle', color: COLOR.muted });

      // destra: price
      const prX = panelX + tableW - prW; const prY = upY;
      drawGlass(prX, prY, prW, badgeH);
      text({ str: priceLabel, x: prX + prW - px(12), y: bottomY+1, size: px(14), weight: 700, align: 'right', baseline: 'middle', color: COLOR.text });
    }

    // Interactivity
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      canvas.style.cursor = hit ? 'pointer' : 'default';
    });
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const hit = linkHitboxes.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
      if (hit && hit.url && hit.url.startsWith('http')) window.open(hit.url, '_blank', 'noopener');
    });

    window.addEventListener('resize', draw);
    refreshData();
    setInterval(refreshData, 5*60*1000);
  </script>
</body>
</html>

